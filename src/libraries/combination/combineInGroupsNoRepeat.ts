/**
 * Return an array of ordered combination without repetition of n objets classified in k groups.
 * @param objects An array of object to reorder.
 * @param k The number of classified groups.
 * @returns An array where each cell contain the grouping result of the object.
 */
export function combineInGroupsNoRepeat<T>(objects: T[], k: number): T[][]
{
    const n = objects.length; // Assign n as the length of all objets or the number passed through the function
    if(n < k) // n must be greater or equal to k...
    {
        throw new Error(`The number of objects must be greater or equal to ${n} for k=${k}.`);
    }
    const offset = n - k + 1; // The offset generated by the number of group
    const result: any[] = []; // Declare the result
    for(let i = 0; i < offset; i++) // Loop through all possible values on the first element
    {
        const content: T[] = [];
        content.push(objects[i]);
        Array.prototype.push.apply(result, combinationArrayDepthNRNO(objects, // Pass our objects
            i + 1, // Go to the next index to get the start of the next element
            offset + 1, // Subgroup gain a start offset of 1
            k - 1, // Align k for depth check since array start at 0
            0, // No depth, it's the 1st subgroup
            content // Pass the container of objets itself for referencing
        )); // Combine result
    }
    return result; // Return the result
}
/***
 * Generate an array of the entire set of element made out of binomial coefficient by taking the depth stack into account.
 */
function combinationArrayDepthNRNO<T>(objects: T[], index: number, offset: number, k: number, depth: number = 0, content: T[] = []): any
{
    if(depth >= k) { // If our depth is grater or equal to k, then we have all we need
        return [content]; // We return the new array of objects made on the way.
    }
    const result: any = []; // Declare a result
    for(let i = index; i < offset; i++) // Loop through the possible values between index and offset - 1
    {
        Array.prototype.push.apply(result, combinationArrayDepthNRNO(objects,
            i + 1, // Go to the next index to get the start of the next element
            offset + 1, // Subgroup gain a start offset of 1
            k, // Just passing k along, it's already align if nothing goes wrong
            depth + 1, // Next depth of the stack
            [...content, objects[i]]  // Pass the container of newly packed objets itself for referencing
        )); // Combine result
    }
    return result; // Return the result
}